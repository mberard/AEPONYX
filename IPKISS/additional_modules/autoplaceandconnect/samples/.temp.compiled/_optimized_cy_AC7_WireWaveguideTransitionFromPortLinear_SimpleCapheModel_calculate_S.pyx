
'''
This file is automatically generated by the Caphe optimizer, by using the
@optimize.compile_function decorator.
It is a pyx file, which is compiled by Cython to C code, which is then compiled
and loaded by Caphe.

Do not modify this file. Instead, modify your functions.
'''

import numpy as np
cimport numpy as np
import cython

# Additional functions from the C math library.
from libc.math cimport sqrt as real_sqrt, sin as real_sin, cos as real_cos, exp as real_exp

# Additional C++ functions
cdef extern from "complex":
    np.complex128_t exp(np.complex128_t z)
    np.complex128_t sqrt(np.complex128_t z)
    np.complex128_t conj(np.complex128_t z)
    np.complex128_t sin(np.complex128_t z)
    np.complex128_t cos(np.complex128_t z)
    np.complex128_t arg(np.complex128_t z)
    np.complex128_t tanh(np.complex128_t z)

    np.float64_t  atan2(np.float64_t  z1, np.float64_t  z2)
    np.float64_t  floor(np.float64_t  z)
    np.float64_t  ceil(np.float64_t  z)

    # We use the real-valued definition, to make conversions easier.
    #np.complex128_t real(np.complex128_t z)
    np.float64_t real(np.complex128_t z)
    #np.complex128_t imag(np.complex128_t z)
    np.float64_t imag(np.complex128_t z)
    #np.complex128_t abs(np.complex128_t z)
    np.float64_t abs(np.complex128_t z)



# For PyObject, which we need for numpy array passing from C++ to Cython.
from cpython.ref cimport PyObject

from libcpp.vector cimport vector
from libcpp.string cimport string
from libcpp cimport bool

cdef extern from "CPropertyObject.h":
    cdef cppclass CPropertyObject:
        CPropertyObject()
        vector[double] double_values
        vector[complex] dcomplex_values
        vector[int] int_values
        vector[bool] bool_values
        #vector[ np.ndarray[complex] ] numpy_array_values (currently read-only)

        CPropertyObject *environment

        int double_change_parameter(string, double)
        int get_index_of_double_name(string)
        double get_double_value_from_pobject(int)
        void list_double_parameters()

        int dcomplex_change_parameter(string, complex)
        int get_index_of_dcomplex_name(string)
        complex get_dcomplex_value_from_pobject(int)
        void list_dcomplex_parameters()

        int int_change_parameter(string, complex)
        int get_index_of_int_name(string)
        int get_int_value_from_pobject(int)
        void list_int_parameters()

        int bool_change_parameter(string, complex)
        int get_index_of_bool_name(string)
        bool get_bool_value_from_pobject(int)
        void list_bool_parameters()

        int numpy_array_change_parameter(string, np.ndarray[complex])
        int get_index_of_numpy_array_name(string)
        PyObject * get_numpy_array_value_from_pobject(int)
        void list_numpy_array_parameters()


cdef extern from "CyclicBuffer.h":
    cdef cppclass CyclicBufferSlice[D]:
        D operator()(double)
        D operator[](int)
        D get_state_at(double)

    cdef cppclass CyclicBuffer[D]:
        CyclicBufferSlice[D] operator[](int)
        CyclicBufferSlice[D] get_slice(int index)

        int get_delay1(double)
        double get_current_time()

cdef double pi = np.pi
cdef arange = np.arange


@cython.cdivision(True)
cdef public double complex _optimized_cy_AC7_WireWaveguideTransitionFromPortLinear_SimpleCapheModel_calculate_S(CPropertyObject* self, CPropertyObject* node, CPropertyObject* environment, int p1, int p2) : 
    cdef double dneff
    cdef double neff_total
    cdef double loss
    
    """Calculate physical ports / modes from p1 / p2. Cython does not recognize divmod nicely, so we use % and // functions instead"""
    ph_p1 = p1 % node.get_int_value_from_pobject(0)
    m1 = p1 // node.get_int_value_from_pobject(0)
    ph_p2 = p2 % node.get_int_value_from_pobject(0)
    m2 = p2 // node.get_int_value_from_pobject(0)
    
    if ((ph_p1 == 0 and ph_p2 == 1) or 
        (ph_p1 == 1 and ph_p2 == 0)):
        wavelength = environment.get_double_value_from_pobject(0)
        dneff = -(self.get_double_value_from_pobject(4) - self.get_double_value_from_pobject(3)) / self.get_double_value_from_pobject(0)
        neff_total = self.get_double_value_from_pobject(3) + (wavelength - self.get_double_value_from_pobject(0)) * dneff
        loss = 10 ** (-self.get_double_value_from_pobject(2) * self.get_double_value_from_pobject(1) * 1e-6  / 20.0)
        return exp(1j * 2 * pi / wavelength * neff_total * self.get_double_value_from_pobject(1)) * loss
    else:
        return 0
    
    
