from ipkiss3.pcell.routing.manhattan import route_manhattan, RouteManhattanBasic
from ipcore.properties.restrictions import RestrictTypeList
from ipkiss3.pcell.photonics.port import InPlanePort
from ipcore.properties.predefined import ListProperty
from ipkiss3 import all as i3
from ipkiss.geometry.vector import Vector
from ipkiss.plugins.documentation import example_plot
from ipkiss.geometry.shape_info import angle_manhattan, angle_deg
import numpy as np

manhattan_dirs = np.array([0., 90., 180., 270., 360.])


def _bind_angle(angle):
    """
    Returns a rounded angle between 0, 360
    """
    return (angle + 360.0) % 360


def _get_angle_out(pos1, pos2, angle_in):
    """
    Returns angle out for a manhattan route as a function of pos1, pos2 and angle in2

    Parameters
    ----------

    pos1: start_position of the route (where angle out is applied)
    pos2: end_position of the route (where angle out is applied)
    angle_in : angle of the route leaving the previous control point (of this route)

    Returns
    -------

    angle_out: angle in degrees
    """

    idy = pos2[1] == pos1[1]
    is_above = pos2[1] > pos1[1]

    idx = pos2[0] == pos1[0]
    is_right = pos2[0] > pos1[0]


    if idx:
        if is_above:
            return 90.0
        else:
            return 270.0

    if idy:
        if is_right:
            return 0.0
        else:
            return 180.0

    _angle_in = angle_manhattan(angle_in % 360)
    angle_in_flight_line = angle_deg(pos2, origin=pos1) % 360
    index_c = np.where(manhattan_dirs > angle_in_flight_line)[0][0]
    possible_dirs = [manhattan_dirs[index_c - 1], manhattan_dirs[index_c]]
    forbidden_dir = (_angle_in) % 360.0
    return filter(lambda i: i % 360.0 != forbidden_dir, possible_dirs)[0]


def _get_angle_in(pos1, pos2, angle_out):
    """
    Returns angle in for a manhattsan route as a function of pos1, pos2 and angle in2

    Parameters
    ----------
    pos1: start_position of the route (where angle out is applied)
    pos2: end_position of the route (where angle out is applied)
    angle_out : angle of the route leaving the previous control point
    Returns
    -------

    angle_in: angle in degrees
    """

    idy = pos2[1] == pos1[1]
    is_above = pos2[1] > pos1[1]

    idx = pos2[0] == pos1[0]
    is_right = pos2[0] > pos1[0]

    if idx:
        if is_above:
            return 90.0
        else:
            return 270.0

    if idy:
        if is_right:
            return 0.0
        else:
            return 180.0

    _angle_out = angle_manhattan(angle_out % 360)
    flight_line_angle_in = angle_deg(pos2, origin=pos1) % 360
    index_c = np.where(manhattan_dirs > flight_line_angle_in)[0][0]
    possible_dirs = [manhattan_dirs[index_c - 1], manhattan_dirs[index_c]]
    forbidden_dir = (_angle_out + 180.0) % 360.0
    return filter(lambda i: i % 360.0 != forbidden_dir, possible_dirs)[0]


class RouteManhattanControlPoints(RouteManhattanBasic):

    """
    Manhattan route that goes through a list of control points. The route generated by RouteManhattanControlPoints will
    have the following properties:

    - The route is a regular manhattan route.
    - The route goes through the control_points in the order same order as in control_points.
    - The route can intersect with itself if the control_points are poorly chosen.
    - The route may not be bend-radius safe (that is require to sharp bends) if the control are poorly chosen.
    """

    control_points = ListProperty(doc="List of points through which the route has to pass")

    @example_plot()
    def __example1(cls):
        from technologies import silicon_photonics
        from picazzo3.fibcoup.curved import FiberCouplerCurvedGrating
        from picazzo3.routing.place_route import PlaceComponents
        from ipkiss3 import all as i3
        from routing.route_through_control_points import RouteManhattanControlPoints

        # Placing the components of the circuit

        gr = FiberCouplerCurvedGrating()
        circuit = PlaceComponents(child_cells={'gr': gr,
                                               'grb1': gr,
                                               'grb2': gr})

        circuit_layout = circuit.Layout(child_transformations={'gr': (0, 0),
                                                               'grb1': (-100, 0),
                                                               'grb2': i3.Rotation(rotation=180.0) + i3.Translation((+100, 0))})

        # We now use the placed components and make waveguides.

        control_points = [(-40, 20), (50, 0)]

        route = RouteManhattanControlPoints(input_port=circuit_layout.instances['grb1'].ports['out'],
                                            output_port=circuit_layout.instances['grb2'].ports['out'],
                                            control_points=control_points,
                                            rounding_algorithm=None
                                            )

        wire = i3.RoundedWaveguide()
        wl = wire.Layout(shape=route)

        # We create a new placecomponents with the wire included.

        circuit_child_cells = dict(circuit.child_cells)
        circuit_child_cells['wire'] = wire
        circuit_with_wire = PlaceComponents(child_cells=circuit_child_cells)
        circuit_with_wire_layout = circuit_with_wire.Layout(child_transformations=circuit_layout.child_transformations)
        circuit_with_wire_layout.visualize()

    @example_plot()
    def __example_2(cls):
        from technologies import silicon_photonics
        from picazzo3.fibcoup.curved import FiberCouplerCurvedGrating
        from picazzo3.routing.place_route import PlaceComponents
        from ipkiss3 import all as i3
        from routing.route_through_control_points import RouteManhattanControlPoints

        class BondPad(i3.PCell):

            """
            Bondpad to be used here
            """
            class Layout(i3.LayoutView):
                size = i3.Size2Property(default=(50.0, 50.0), doc="Size of the bondpad")
                metal_layer = i3.LayerProperty(default=i3.TECH.PPLAYER.M1.LINE, doc="Metal used for the bondpad")

                def _generate_elements(self, elems):
                    elems += i3.Rectangle(layer=self.metal_layer, box_size=self.size)
                    return elems

                def _generate_ports(self, ports):
                    ports += i3.ElectricalPort(name="m1", position=(0.0, 0.0), shape=self.size, process=self.metal_layer.process)
                    return ports

        # Placing the components of the circuit
        bp = BondPad()
        bp_layout = bp.Layout(size=(50, 50))
        gr = FiberCouplerCurvedGrating()
        circuit = PlaceComponents(child_cells={'gr': gr,
                                               'gr2': gr,
                                               'b1': bp,
                                               'b2': bp})

        circuit_layout = circuit.Layout(child_transformations={'gr': (0, 0),
                                                               'gr2': (150, 0),
                                                               'b1': (-200, 0),
                                                               'b2': (+200, 0)})

        # We now use the placed components and make wire.

        control_points = [(-40, 20), (50, 0), (100, -50)]

        route = RouteManhattanControlPoints(input_port=circuit_layout.instances['b1'].ports['m1'],
                                            output_port=circuit_layout.instances['b2'].ports['m1'],
                                            control_points=control_points,
                                            angle_out=90.0,  # We override the default angle of the route
                                            rounding_algorithm=None
                                            )
        wire_template = i3.ElectricalWireTemplate()
        wire_template.Layout(width=2.0, layer=bp_layout.metal_layer)

        wire = i3.ElectricalWire()
        wl = wire.Layout(shape=route)

        # We create a new placecomponents with the wire included.

        circuit_child_cells = dict(circuit.child_cells)
        circuit_child_cells['wire'] = wire
        circuit_with_wire = PlaceComponents(child_cells=circuit_child_cells)
        circuit_with_wire_layout = circuit_with_wire.Layout(child_transformations=circuit_layout.child_transformations)
        circuit_with_wire_layout.visualize()

    def _default_control_points(self):
        return []

    def _get_used_control_point_in_out_angles(self):
        "Calculates the in and out angles in each control point"

        used_start_control_points = [self.input_port.position]
        used_stop_control_points = [self.control_points[0]]
        in_angles = [self.angle_in % 360]
        out_angles = [_get_angle_out(used_start_control_points[0], used_stop_control_points[0], in_angles[0])]

        for cnt, wp in enumerate(self.control_points[1:], 1):

            used_start_control_points.append(used_stop_control_points[-1])
            used_stop_control_points.append(wp)

            in_angles.append(_get_angle_in(used_start_control_points[-1], used_stop_control_points[-1], out_angles[-1]))
            out_angles.append(_get_angle_out(used_start_control_points[-1], used_stop_control_points[-1], in_angles[-1]))

        used_start_control_points.append(used_stop_control_points[-1])
        used_stop_control_points.append(self.output_port.position)

        in_angles.append(_get_angle_in(used_start_control_points[-1], used_stop_control_points[-1], out_angles[-1]))
        out_angles.append(self.angle_out)

        return used_start_control_points, in_angles, used_stop_control_points, out_angles

    def _default_points(self, pts):

        # If no control points are given.
        if len(self.control_points) == 0:
            pts = super(RouteManhattanControlPoints, self)._default_points(pts)
            return pts
        else:
            used_start_control_points, in_angles, used_stop_control_points, out_angles = self._get_used_control_point_in_out_angles()
            pts.append(self.input_port.position)
            for cnt, (start_wp, ia, stop_wp, oa) in enumerate(zip(used_start_control_points, in_angles, used_stop_control_points, out_angles)):

                if cnt == 0 or cnt == len(self.control_points) + 1:
                    start_straight = self.start_straight
                    end_straight = self.end_straight
                else:
                    start_straight = 0
                    end_straight = 0

                to_add = route_manhattan(start_wp, ia,
                                         stop_wp, oa,
                                         self.get_bend_size, self.get_bend90_size,
                                         min_straight=self.min_straight,
                                         start_straight=start_straight,
                                         end_straight=end_straight,
                                         min_spacing=self.min_spacing)[1:]  # Not the first point to avoid double counting

                for to in to_add:
                    pts.append(i3.Coord2(to))

        return pts
