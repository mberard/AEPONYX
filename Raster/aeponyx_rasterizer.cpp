/*******************************************************************************
 * Macro Name: Macro1
 * Creator  :
 *
 * Revision History:
 * 13 Sep 2017	Generated by L-Edit
 *******************************************************************************/
#include <cstdlib>
#include <cstdarg>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <cmath>

#include <string>

#define ALGORITHM_A

#define EXCLUDE_LEDIT_LEGACY_UPI

#include <ldata.h>
/* Begin -- Uncomment this block if you are using L-Comp. */
//#include <lcomp.h>
/* End */

#include "vector"

extern "C" {
	void Rasterize(void);
	int UPI_Entry_Point(void);
}

LCoord Round(double d)
{
	if (d >= 0)
		return d+0.5;
	else
		return d-0.5;
}

LCoord nLastx;
LCoord nLasty;

bool bLastSegVertical = true;

void Add( double x, double y, std::vector<LPoint>& vVerts )
{
	LCoord nx = Round( x );
	LCoord ny = Round( y );

	if ( ! vVerts.empty() && nx == nLastx && ny == nLasty )
		return; // do not duplicate vertex

	vVerts.push_back( LPoint_Set( nx, ny ) );
	
	nLastx = nx;
	nLasty = ny;
}

void Rasterize(void)
{
	LCell	pCell	=	LCell_GetVisible();
	LFile	pFile	=	LCell_GetFile(pCell);

	if ( ! pCell )
		return;

	LGrid_v16_30 grid;
	LFile_GetGrid_v16_30( pFile, &grid );

#ifndef ALGORITHM_A
	double dArcSegLen = grid.manufacturing_grid_size * 10.0;
#endif

	std::vector<LObject> vDeselect;

	std::vector<LPoint> vVerts;
	LSelection pSelNext = NULL;
	for ( LSelection pSel = LSelection_GetList(); pSel; pSel = pSelNext )
	{
		pSelNext = LSelection_GetNext(pSel);
		LObject pObj = LSelection_GetObject(pSel);

		vVerts.clear();

		if (LObject_GetShape(pObj) == LCircle)
		{
//			LDialog_MsgBox("Found a circle");
			LPoint ptCenter = LCircle_GetCenter(pObj);
			LCoord nRadius = LCircle_GetRadius(pObj);

#ifdef ALGORITHM_A
			double dThetaStep = 2*acos(1 - (double)grid.manufacturing_grid_size / nRadius / 10);
			for (double dTheta = 0; dTheta < 2.0 * M_PI; dTheta += dThetaStep )
				Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
#else
			int n = 2.0 * M_PI * (double)nRadius / dArcSegLen;
			if ( n < 8 )
				n = 8;
			double dThetaStep = 2.0 * M_PI / n;
			for ( int i = 0; i < n; i++ )
			{
				double dTheta = i * dThetaStep;
				Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
			}
#endif
		}
		else if (LObject_GetGeometry(pObj) != LCurved)
		{
			vDeselect.push_back(pObj);
			continue;
		}

		switch( LObject_GetShape(pObj) )
		{
			case LPolygon:
//				LDialog_MsgBox("Found a curved polygon");
				for (LVertex pVert = LObject_GetVertexList(pObj); pVert; pVert = LVertex_GetNext(pVert))
				{
//					char msg[200];
//					sprintf(msg, "Found a vertex (%ld, %ld)", LVertex_GetPoint(pVert).x, LVertex_GetPoint(pVert).y);
//					LDialog_MsgBox(msg);
					Add( LVertex_GetPoint(pVert).x, LVertex_GetPoint(pVert).y, vVerts );
					if ( ! LVertex_HasCurve(pVert))
						continue;

					LPoint ptStart;
					LPoint ptEnd;
					LPoint ptCenter;
					LArcDirection Dir;
					LCoord nRadius;
					LVertex_GetCurveEX(pObj, pVert, &ptCenter, &nRadius, &ptStart, &ptEnd, &Dir);

					double dStartAngle = atan2( ptStart.y - ptCenter.y, ptStart.x - ptCenter.x );
					double dStopAngle = atan2( ptEnd.y - ptCenter.y, ptEnd.x - ptCenter.x );

//					sprintf(msg, "Found a curved vertex center (%ld, %ld) start = %g end = %g", ptCenter.x, ptCenter.y, dStartAngle, dStopAngle);
//					LDialog_MsgBox(msg);

					if ( Dir == CCW )
					{
						// ensure dEndAngle > dStartAngle
						while (dStopAngle < dStartAngle)
							dStopAngle += 2.0 * M_PI;

#ifdef ALGORITHM_A
						Add( ptCenter.x + nRadius * cos( dStartAngle ), ptCenter.y + nRadius * sin( dStartAngle ), vVerts );
						double dThetaStep = 2*acos(1 - (double)grid.manufacturing_grid_size / nRadius / 10);
						for (double dTheta = dStartAngle; dTheta < dStopAngle; dTheta += dThetaStep )
							Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
						Add( ptCenter.x + nRadius * cos( dStopAngle ), ptCenter.y + nRadius * sin( dStopAngle ), vVerts );
#else
						// insert n vertices
						int n = Round( (dStopAngle - dStartAngle) * nRadius / dArcSegLen );
						double dThetaStep = (dStopAngle - dStartAngle) / (n + 1);

//						sprintf(msg, "CCW verts = %d", n);
//						LDialog_MsgBox(msg);

						Add( ptCenter.x + nRadius * cos( dStartAngle ), ptCenter.y + nRadius * sin( dStartAngle ), vVerts );
						for ( int i = 1; i <= n; i++ )
						{
							double dTheta = dStartAngle + i * dThetaStep;
							Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
						}
#endif
					}
					else
					{
						// Dir == CW

						// ensure dStartAngle > dEndAngle
						while (dStartAngle < dStopAngle)
							dStartAngle += 2.0 * M_PI;

#ifdef ALGORITHM_A
						Add( ptCenter.x + nRadius * cos( dStartAngle ), ptCenter.y + nRadius * sin( dStartAngle ), vVerts );
						double dThetaStep = 2*acos(1 - (double)grid.manufacturing_grid_size / nRadius / 10);
						for (double dTheta = dStartAngle; dTheta > dStopAngle; dTheta -= dThetaStep )
							Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
						Add( ptCenter.x + nRadius * cos( dStopAngle ), ptCenter.y + nRadius * sin( dStopAngle ), vVerts );
#else
						// insert n vertices
						int n = Round( (dStartAngle - dStopAngle) * nRadius / dArcSegLen);
						double dThetaStep = (dStartAngle - dStopAngle) / (n + 1);

//						sprintf(msg, "CW verts = %d", n);
//						LDialog_MsgBox(msg);

						Add( ptCenter.x + nRadius * cos( dStartAngle ), ptCenter.y + nRadius * sin( dStartAngle ), vVerts );
						for ( int i = 1; i <= n; i++ )
						{
							double dTheta = dStartAngle - i * dThetaStep;
							Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
						}
#endif
					}
				}
				break;

			case LTorus:
			{
				LTorusParams TorusParams;
				LTorus_GetParams(pObj, &TorusParams);
				double dStartAngle = TorusParams.dStartAngle * M_PI / 180.0;
				double dStopAngle = TorusParams.dStopAngle * M_PI / 180.0;
				while (dStopAngle < dStartAngle)
					dStopAngle += 2.0 * M_PI;
//				LDialog_MsgBox("Found a torus");
//				char msg[200];
//				sprintf(msg, "Start = %g Stop = %g", dStartAngle, dStopAngle);
//				LDialog_MsgBox(msg);

				// draw the polygon in CW direction, from start/inner

				LPoint ptCenter = TorusParams.ptCenter;
				LCoord nRadius = TorusParams.nInnerRadius;


#ifdef ALGORITHM_A
				Add( ptCenter.x + nRadius * cos( dStartAngle ), ptCenter.y + nRadius * sin( dStartAngle ), vVerts );
				double dThetaStep = 2*acos(1 - (double)grid.manufacturing_grid_size / nRadius / 10);
				for (double dTheta = dStartAngle; dTheta < dStopAngle; dTheta += dThetaStep )
					Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
				Add( ptCenter.x + nRadius * cos( dStopAngle ), ptCenter.y + nRadius * sin( dStopAngle ), vVerts );

				nRadius = TorusParams.nOuterRadius;
				dThetaStep = 2*acos(1 - (double)grid.manufacturing_grid_size / nRadius / 10);

				Add( ptCenter.x + nRadius * cos( dStopAngle ), ptCenter.y + nRadius * sin( dStopAngle ), vVerts );
				for (double dTheta = dStopAngle; dTheta > dStartAngle; dTheta -= dThetaStep )
					Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
				Add( ptCenter.x + nRadius * cos( dStartAngle ), ptCenter.y + nRadius * sin( dStartAngle ), vVerts );
#else

				int n = Round( (dStopAngle - dStartAngle) * nRadius / dArcSegLen );
				if ( n < 8 )
					n = 8;
				double dThetaStep = (dStopAngle - dStartAngle) / n;

				Add( ptCenter.x + nRadius * cos( dStartAngle ), ptCenter.y + nRadius * sin( dStartAngle ), vVerts );
				for ( int i = 1; i <= n; i++ )
				{
					double dTheta = dStartAngle + i * dThetaStep;
					Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
				}

				nRadius = TorusParams.nOuterRadius;
				n = Round( (dStopAngle - dStartAngle) * nRadius / dArcSegLen );
				if ( n < 8 )
					n = 8;
				dThetaStep = (dStopAngle - dStartAngle) / n;

				Add( ptCenter.x + nRadius * cos( dStopAngle ), ptCenter.y + nRadius * sin( dStopAngle ), vVerts );
				for ( int i = 1; i <= n; i++ )
				{
					double dTheta = dStopAngle - i * dThetaStep;
					Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
				}
#endif
				break;
			}

			case LPie:
			{
				LPieParams PieParams;
				LPie_GetParams(pObj, &PieParams);
				double dStartAngle = PieParams.dStartAngle * M_PI / 180.0;
				double dStopAngle = PieParams.dStopAngle * M_PI / 180.0;
				while (dStopAngle < dStartAngle)
					dStopAngle += 2.0 * M_PI;
//				LDialog_MsgBox("Found a pie");
//				char msg[200];
//				sprintf(msg, "Start = %g Stop = %g", dStartAngle, dStopAngle);
//				LDialog_MsgBox(msg);

				// draw the polygon in CW direction, from start/inner

				LPoint ptCenter = PieParams.ptCenter;
				LCoord nRadius = PieParams.nRadius;
#ifdef ALGORITHM_A
				double dThetaStep = 2*acos(1 - (double)grid.manufacturing_grid_size / nRadius / 10);
				for ( double dTheta = dStartAngle; dTheta < dStopAngle; dTheta += dThetaStep )
					Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
				Add( ptCenter.x + nRadius * cos( dStopAngle ), ptCenter.y + nRadius * sin( dStopAngle ), vVerts );
				Add( PieParams.ptCenter.x, PieParams.ptCenter.y, vVerts );
#else
				int n = Round( (dStopAngle - dStartAngle) * nRadius / dArcSegLen );
				if ( n < 8 )
					n = 8;
				double dThetaStep = (dStopAngle - dStartAngle) / n;
				for ( int i = 0; i <= n; i++ )
				{
					double dTheta = dStartAngle + i * dThetaStep;
					Add( ptCenter.x + nRadius * cos( dTheta ), ptCenter.y + nRadius * sin( dTheta ), vVerts );
				}
				Add( PieParams.ptCenter.x, PieParams.ptCenter.y, vVerts );
#endif
				break;
			}

			default:
				break;
		}

		if (vVerts.empty())
			vDeselect.push_back(pObj);
		else
			LPolygon_New( pCell, LSelection_GetLayer(pSel), &vVerts.front(), vVerts.size() );
	}

	for (size_t i = 0; i < vDeselect.size(); i++ )
		LSelection_RemoveObject(vDeselect[i]);
	LSelection_Clear();
	LDisplay_Refresh();
}

int UPI_Entry_Point(void)
{
	LMacro_BindToMenuAndHotKey_v9_30("Tools", NULL /*hotkey*/,
			"Rasterize Selections", "Rasterize", NULL /*hotkey category*/);
	return 1;
}
